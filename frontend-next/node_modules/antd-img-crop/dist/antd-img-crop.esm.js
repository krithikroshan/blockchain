function __$styleInject(css) {
    if (!css) return;

    if (typeof window == 'undefined') return;
    var style = document.createElement('style');
    style.setAttribute('media', 'screen');

    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
}

import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import React, { memo, forwardRef, useState, useCallback, useEffect, useRef, useMemo } from 'react';
import t from 'prop-types';
import Cropper from 'react-easy-crop';
import LocaleReceiver from 'antd/es/locale-provider/LocaleReceiver';
import Modal from 'antd/es/modal';
import Slider from 'antd/es/slider';

__$styleInject(".antd-img-crop-modal .ant-modal-body {\n  padding-bottom: 16px;\n}\n.antd-img-crop-modal .antd-img-crop-container {\n  position: relative;\n  width: 100%;\n  height: 40vh;\n  margin-bottom: 16px;\n}\n.antd-img-crop-modal .antd-img-crop-control {\n  display: flex;\n  align-items: center;\n  width: 60%;\n  margin-left: auto;\n  margin-right: auto;\n}\n.antd-img-crop-modal .antd-img-crop-control button {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 34px;\n  height: 34px;\n  padding: 0;\n  font-style: normal;\n  background: transparent;\n  border: 0;\n  outline: 0;\n  cursor: pointer;\n}\n.antd-img-crop-modal .antd-img-crop-control button[disabled] {\n  cursor: default;\n}\n.antd-img-crop-modal .antd-img-crop-control.zoom button {\n  font-size: 18px;\n}\n.antd-img-crop-modal .antd-img-crop-control.rotate button {\n  font-size: 16px;\n}\n.antd-img-crop-modal .antd-img-crop-control.rotate button:first-of-type {\n  transform: rotate(-20deg);\n}\n.antd-img-crop-modal .antd-img-crop-control.rotate button:last-of-type {\n  transform: rotate(20deg);\n}\n.antd-img-crop-modal .antd-img-crop-control .ant-slider {\n  flex: 1;\n  margin: 0 8px;\n}\n");

var _excluded = ["beforeUpload", "accept"];
var pkg = 'antd-img-crop';
var INIT_ZOOM = 1;
var ZOOM_STEP = 0.1;
var INIT_ROTATE = 0;
var ROTATE_STEP = 1;
var MIN_ROTATE = -180;
var MAX_ROTATE = 180;
var EasyCrop = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function (props, ref) {
  var src = props.src,
      aspect = props.aspect,
      shape = props.shape,
      grid = props.grid,
      zoom = props.zoom,
      rotate = props.rotate,
      rotateValRef = props.rotateValRef,
      setZoomValRef = props.setZoomValRef,
      setRotateValRef = props.setRotateValRef,
      minZoom = props.minZoom,
      maxZoom = props.maxZoom,
      cropPixelsRef = props.cropPixelsRef,
      cropperProps = props.cropperProps;

  var _useState = useState({
    x: 0,
    y: 0
  }),
      crop = _useState[0],
      setCrop = _useState[1];

  var _useState2 = useState({
    width: 0,
    height: 0
  }),
      cropSize = _useState2[0],
      setCropSize = _useState2[1];

  var onCropComplete = useCallback(function (croppedArea, croppedAreaPixels) {
    cropPixelsRef.current = croppedAreaPixels;
  }, [cropPixelsRef]);
  var onMediaLoaded = useCallback(function (mediaSize) {
    var width = mediaSize.width,
        height = mediaSize.height;
    var ratioWidth = height * aspect;

    if (width > ratioWidth) {
      setCropSize({
        width: ratioWidth,
        height: height
      });
    } else {
      setCropSize({
        width: width,
        height: width / aspect
      });
    }
  }, [aspect]);

  var _useState3 = useState(INIT_ZOOM),
      zoomVal = _useState3[0],
      setZoomVal = _useState3[1];

  var _useState4 = useState(INIT_ROTATE),
      rotateVal = _useState4[0],
      setRotateVal = _useState4[1];

  rotateValRef.current = rotateVal;
  useEffect(function () {
    setZoomValRef.current = setZoomVal;
    setRotateValRef.current = setRotateVal;
  }, [setRotateValRef, setZoomValRef]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Cropper, Object.assign({}, cropperProps, {
    ref: ref,
    image: src,
    crop: crop,
    cropSize: cropSize,
    onCropChange: setCrop,
    aspect: aspect,
    cropShape: shape,
    showGrid: grid,
    zoomWithScroll: zoom,
    zoom: zoomVal,
    rotation: rotateVal,
    onZoomChange: setZoomVal,
    onRotationChange: setRotateVal,
    minZoom: minZoom,
    maxZoom: maxZoom,
    onCropComplete: onCropComplete,
    onMediaLoaded: onMediaLoaded,
    classes: {
      containerClassName: pkg + "-container",
      mediaClassName: pkg + "-media"
    }
  })), zoom && /*#__PURE__*/React.createElement("div", {
    className: pkg + "-control zoom"
  }, /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      return setZoomVal(zoomVal - ZOOM_STEP);
    },
    disabled: zoomVal - ZOOM_STEP < minZoom
  }, "\uFF0D"), /*#__PURE__*/React.createElement(Slider, {
    min: minZoom,
    max: maxZoom,
    step: ZOOM_STEP,
    value: zoomVal,
    onChange: setZoomVal
  }), /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      return setZoomVal(zoomVal + ZOOM_STEP);
    },
    disabled: zoomVal + ZOOM_STEP > maxZoom
  }, "\uFF0B")), rotate && /*#__PURE__*/React.createElement("div", {
    className: pkg + "-control rotate"
  }, /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      return setRotateVal(rotateVal - ROTATE_STEP);
    },
    disabled: rotateVal === MIN_ROTATE
  }, "\u21BA"), /*#__PURE__*/React.createElement(Slider, {
    min: MIN_ROTATE,
    max: MAX_ROTATE,
    step: ROTATE_STEP,
    value: rotateVal,
    onChange: setRotateVal
  }), /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      return setRotateVal(rotateVal + ROTATE_STEP);
    },
    disabled: rotateVal === MAX_ROTATE
  }, "\u21BB")));
}));
EasyCrop.propTypes = {
  src: t.string,
  aspect: t.number,
  shape: t.string,
  grid: t.bool,
  zoom: t.bool,
  rotate: t.bool,
  rotateValRef: t.object,
  setZoomValRef: t.object,
  setRotateValRef: t.object,
  minZoom: t.number,
  maxZoom: t.number,
  cropPixelsRef: t.object,
  cropperProps: t.object
};
var ImgCrop = /*#__PURE__*/forwardRef(function (props, ref) {
  var aspect = props.aspect,
      shape = props.shape,
      grid = props.grid,
      quality = props.quality,
      zoom = props.zoom,
      rotate = props.rotate,
      minZoom = props.minZoom,
      maxZoom = props.maxZoom,
      fillColor = props.fillColor,
      modalTitle = props.modalTitle,
      modalWidth = props.modalWidth,
      modalOk = props.modalOk,
      modalCancel = props.modalCancel,
      onModalOk = props.onModalOk,
      onModalCancel = props.onModalCancel,
      beforeCrop = props.beforeCrop,
      onUploadFail = props.onUploadFail,
      cropperProps = props.cropperProps,
      children = props.children;
  /**
   * Upload
   */

  var _useState5 = useState(''),
      src = _useState5[0],
      setSrc = _useState5[1];

  var fileRef = useRef();
  var resolveRef = useRef();
  var rejectRef = useRef();
  var beforeUploadRef = useRef();
  var renderUpload = useCallback(function () {
    var upload = Array.isArray(children) ? children[0] : children;

    var _upload$props = upload.props,
        beforeUpload = _upload$props.beforeUpload,
        accept = _upload$props.accept,
        restUploadProps = _objectWithoutPropertiesLoose(_upload$props, _excluded);

    beforeUploadRef.current = beforeUpload;
    return _extends({}, upload, {
      props: _extends({}, restUploadProps, {
        accept: accept || 'image/*',
        beforeUpload: function beforeUpload(file, fileList) {
          return new Promise( /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {
              var reader;
              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.t0 = beforeCrop;

                      if (!_context.t0) {
                        _context.next = 5;
                        break;
                      }

                      _context.next = 4;
                      return beforeCrop(file, fileList);

                    case 4:
                      _context.t0 = !_context.sent;

                    case 5:
                      if (!_context.t0) {
                        _context.next = 8;
                        break;
                      }

                      reject();
                      return _context.abrupt("return");

                    case 8:
                      fileRef.current = file;

                      resolveRef.current = function (newFile) {
                        onModalOk == null ? void 0 : onModalOk(newFile);
                        resolve(newFile);
                      };

                      rejectRef.current = function (uploadErr) {
                        onUploadFail == null ? void 0 : onUploadFail(uploadErr);
                        reject(uploadErr);
                      };

                      reader = new FileReader();
                      reader.addEventListener('load', function () {
                        setSrc(reader.result);
                      });
                      reader.readAsDataURL(file);

                    case 14:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            return function (_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }());
        }
      })
    });
  }, [beforeCrop, children, onModalOk, onUploadFail]);
  /**
   * Crop
   */

  var rotateValRef = useRef();
  var setZoomValRef = useRef();
  var setRotateValRef = useRef();
  var cropPixelsRef = useRef();
  /**
   * Modal
   */

  var modalProps = useMemo(function () {
    var obj = {
      width: modalWidth,
      okText: modalOk,
      cancelText: modalCancel
    };
    Object.keys(obj).forEach(function (key) {
      if (!obj[key]) delete obj[key];
    });
    return obj;
  }, [modalCancel, modalOk, modalWidth]);
  var onClose = useCallback(function () {
    setSrc('');
    setZoomValRef.current(INIT_ZOOM);
    setRotateValRef.current(INIT_ROTATE);
  }, []);
  var onCancel = useCallback(function () {
    onModalCancel == null ? void 0 : onModalCancel();
    onClose();
  }, [onClose, onModalCancel]);
  var onOk = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
    var rawImg, _cropPixelsRef$curren, cropWidth, cropHeight, cropX, cropY, canvas, ctx, rawWidth, rawHeight, boxSize, imgWidth, imgHeight, ratio, half, imgX, imgY, rotatedImg, _fileRef$current, type, name, uid;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            onClose();
            rawImg = document.querySelector("." + pkg + "-media");
            _cropPixelsRef$curren = cropPixelsRef.current, cropWidth = _cropPixelsRef$curren.width, cropHeight = _cropPixelsRef$curren.height, cropX = _cropPixelsRef$curren.x, cropY = _cropPixelsRef$curren.y;
            canvas = document.createElement('canvas');
            ctx = canvas.getContext('2d');

            if (rotate && rotateValRef.current !== 0) {
              // make canvas to cover the rotated image
              rawWidth = rawImg.naturalWidth, rawHeight = rawImg.naturalHeight;
              boxSize = Math.sqrt(Math.pow(rawWidth, 2) + Math.pow(rawHeight, 2));
              imgWidth = rawWidth;
              imgHeight = rawHeight; // fit the long image

              if (boxSize > 4096) {
                ratio = 4096 / boxSize;
                boxSize = 4096;
                imgWidth = rawWidth * ratio;
                imgHeight = rawHeight * ratio;
                cropWidth = cropWidth * ratio;
                cropHeight = cropHeight * ratio;
                cropX = cropX * ratio;
                cropY = cropY * ratio;
              }

              canvas.width = boxSize;
              canvas.height = boxSize; // rotate image

              half = boxSize / 2;
              ctx.translate(half, half);
              ctx.rotate(rotateValRef.current * Math.PI / 180);
              ctx.translate(-half, -half); // draw rotated image to canvas center

              ctx.fillStyle = fillColor;
              ctx.fillRect(0, 0, boxSize, boxSize);
              imgX = (boxSize - imgWidth) / 2;
              imgY = (boxSize - imgHeight) / 2;
              ctx.drawImage(rawImg, 0, 0, rawWidth, rawHeight, imgX, imgY, imgWidth, imgHeight);
              rotatedImg = ctx.getImageData(0, 0, boxSize, boxSize); // resize canvas to crop size

              canvas.width = cropWidth;
              canvas.height = cropHeight;
              ctx.fillStyle = fillColor;
              ctx.fillRect(0, 0, cropWidth, cropHeight);
              ctx.putImageData(rotatedImg, -(imgX + cropX), -(imgY + cropY));
            } else {
              canvas.width = cropWidth;
              canvas.height = cropHeight;
              ctx.fillStyle = fillColor;
              ctx.fillRect(0, 0, cropWidth, cropHeight);
              ctx.drawImage(rawImg, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
            } // get the new image


            _fileRef$current = fileRef.current, type = _fileRef$current.type, name = _fileRef$current.name, uid = _fileRef$current.uid;
            canvas.toBlob( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blob) {
                var newFile, res, passedFile, _type;

                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        newFile = new File([blob], name, {
                          type: type
                        });
                        newFile.uid = uid;

                        if (!(typeof beforeUploadRef.current !== 'function')) {
                          _context2.next = 4;
                          break;
                        }

                        return _context2.abrupt("return", resolveRef.current(newFile));

                      case 4:
                        res = beforeUploadRef.current(newFile, [newFile]);

                        if (!(typeof res !== 'boolean' && !res)) {
                          _context2.next = 8;
                          break;
                        }

                        console.error('beforeUpload must return a boolean or Promise');
                        return _context2.abrupt("return");

                      case 8:
                        if (!(res === true)) {
                          _context2.next = 10;
                          break;
                        }

                        return _context2.abrupt("return", resolveRef.current(newFile));

                      case 10:
                        if (!(res === false)) {
                          _context2.next = 12;
                          break;
                        }

                        return _context2.abrupt("return", rejectRef.current('not upload'));

                      case 12:
                        if (!(res && typeof res.then === 'function')) {
                          _context2.next = 25;
                          break;
                        }

                        _context2.prev = 13;
                        _context2.next = 16;
                        return res;

                      case 16:
                        passedFile = _context2.sent;
                        _type = Object.prototype.toString.call(passedFile);
                        if (_type === '[object File]' || _type === '[object Blob]') newFile = passedFile;
                        resolveRef.current(newFile);
                        _context2.next = 25;
                        break;

                      case 22:
                        _context2.prev = 22;
                        _context2.t0 = _context2["catch"](13);
                        rejectRef.current(_context2.t0);

                      case 25:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, null, [[13, 22]]);
              }));

              return function (_x3) {
                return _ref3.apply(this, arguments);
              };
            }(), type, quality);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })), [fillColor, onClose, quality, rotate]);

  var renderComponent = function renderComponent(titleOfModal) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, renderUpload(), src && /*#__PURE__*/React.createElement(Modal, Object.assign({
      visible: true,
      wrapClassName: pkg + "-modal",
      title: titleOfModal,
      onOk: onOk,
      onCancel: onCancel,
      maskClosable: false,
      destroyOnClose: true
    }, modalProps), /*#__PURE__*/React.createElement(EasyCrop, {
      ref: ref,
      src: src,
      aspect: aspect,
      shape: shape,
      grid: grid,
      zoom: zoom,
      rotate: rotate,
      rotateValRef: rotateValRef,
      setZoomValRef: setZoomValRef,
      setRotateValRef: setRotateValRef,
      minZoom: minZoom,
      maxZoom: maxZoom,
      cropPixelsRef: cropPixelsRef,
      cropperProps: cropperProps
    })));
  };

  if (modalTitle) return renderComponent(modalTitle);
  return /*#__PURE__*/React.createElement(LocaleReceiver, null, function (locale, localeCode) {
    return renderComponent(localeCode === 'zh-cn' ? '编辑图片' : 'Edit image');
  });
});
ImgCrop.propTypes = {
  aspect: t.number,
  shape: t.oneOf(['rect', 'round']),
  grid: t.bool,
  quality: t.number,
  fillColor: t.string,
  zoom: t.bool,
  rotate: t.bool,
  minZoom: t.number,
  maxZoom: t.number,
  modalTitle: t.string,
  modalWidth: t.oneOfType([t.number, t.string]),
  modalOk: t.string,
  modalCancel: t.string,
  onModalOk: t.func,
  onModalCancel: t.func,
  beforeCrop: t.func,
  onUploadFail: t.func,
  cropperProps: t.object,
  children: t.node
};
ImgCrop.defaultProps = {
  aspect: 1,
  shape: 'rect',
  grid: false,
  quality: 0.4,
  fillColor: 'white',
  zoom: true,
  rotate: false,
  minZoom: 1,
  maxZoom: 3
};

export { ImgCrop as default };
